---
title: "simulations"
output: pdf_document
date: "2025-03-10"
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
set.seed(123)
n=200
library(dplyr)
library(purrr)
library(ggplot2)
library(tidyr)
library(npsm)
library(survival)
library(gridExtra)
library(grid)
```

# Générer les données 

## Générer les fonctions

```{r, echo=TRUE}
gener_tte=function(mu, lambda=1){
  X=rexp(n, rate=lambda)
  C=rexp(n, rate = mu)
  TT=pmin(X,C)
  delta=as.numeric(X==TT)
  delta=abs(1-delta)
  S=Surv(time = TT, event = delta)
  S=as.data.frame(S)
  return(S)
}

gener_continue=function(mean=1, sd=0){
  X=abs(rnorm(n, mean=mean, sd=sd))
  return(data.frame(X))
}

gener_binom=function(prob){
  X=rbinom(n, size = 1, prob = prob)
  X=factor(X)
  return(data.frame(X))
}
```


## Différents scénario
Je prend comme généralités que :

 * pour les binomiales, 1 corresponds à l'évènement d'intérêt et qu'il est meilleur d'avoir 0 que 1
 * pour les tte, une valeur plus grande est préférable, mais cela dépends aussi de la censure
 * pour les continues, il n'y a que des valeurs positives et une valeur plus grande est préférable
 
 Les notations des vecteurs T et C sont les suivantes : T_scénario_cas de figure (resp C_scénario_cas de figure)
 où le scénario varie entre 1 et 3 et les cas de figure entre 1 et 6 comme suit : (1) tte/tte ; (2) tte/continue ; (3) tte/binaire ; (4)  continue/continue ; (5)  continue/binaire ; (6) binaire/binaire. 
  

### Scénario 1 : T uniformément meilleur que C

```{r}
# tte/tte
T_1_1=cbind(gener_tte(1.1, 0.5),gener_tte(0.75,0.33))
C_1_1=cbind(gener_tte(0.8, 2.5),gener_tte(0.33,2.5))

# tte/continue
T_1_2=cbind(gener_tte(0.75, 0.75),gener_continue(2,1))
C_1_2=cbind(gener_tte(0.75,1.5),gener_continue(0,1))

# tte/binaire
T_1_3=cbind(gener_tte(0.75,0.5),gener_binom(0.75))
C_1_3=cbind(gener_tte(0.33,2.3),gener_binom(0.45))

# continue/continue
T_1_4=cbind(gener_continue(3,1),gener_continue(3,2))
C_1_4=cbind(gener_continue(2,1),gener_continue(1,1))

# continue/binaire
T_1_5=cbind(gener_continue(2.5,1),gener_binom(0.65))
C_1_5=cbind(gener_continue(0,2),gener_binom(0.35))

# binaire/binaire
T_1_6=cbind(gener_binom(0.75), gener_binom(0.65))
C_1_6=cbind(gener_binom(0.45), gener_binom(0.5))

```

La visulaisation sert à vérifier si les valeurs correspondent bien au scénario choisis

```{r, visualisation, fig.height=3, fig.width=3}
#### continue/continue

data41=as.data.frame(cbind(T_1_4[,1], C_1_4[,1]))

data_long41 = data41 %>%
  mutate(Groupe_T = "T", Groupe_C = "C") %>%
  tidyr::pivot_longer(cols = c(V1, V2), names_to = "Variable", values_to = "Valeur") %>%
  mutate(Groupe = ifelse(Variable == "V1", "T", "C")) 

ggplot(data_long41, aes(x = Valeur, fill = Groupe)) +
  geom_histogram(bins = 20, alpha = 0.5, color = "black", position = "identity") +
  scale_fill_manual(values = c("T" = "darkblue", "C" = "darkred"), name = "Groupe") +
  theme_classic()

data42=as.data.frame(cbind(T_1_4[,2], C_1_4[,2]))

data_long42 = data42 %>%
  mutate(Groupe_T = "T", Groupe_C = "C") %>%
  tidyr::pivot_longer(cols = c(V1, V2), names_to = "Variable", values_to = "Valeur") %>%
  mutate(Groupe = ifelse(Variable == "V1", "T", "C")) 

ggplot(data_long42, aes(x = Valeur, fill = Groupe)) +
  geom_histogram(bins = 20, alpha = 0.5, color = "black", position = "identity") +
  scale_fill_manual(values = c("T" = "darkblue", "C" = "darkred"), name = "Groupe") +
  theme_classic() +labs(title = "continue/continue 2")

#### continue/binaire

data5=as.data.frame(cbind(T_1_5[,1],C_1_5[,1]))
data_long5 = data5 %>%
  mutate(Groupe_T = "T", Groupe_C = "C") %>%
  tidyr::pivot_longer(cols = c(V1, V2), names_to = "Variable", values_to = "Valeur") %>%
  mutate(Groupe = ifelse(Variable == "V1", "T", "C")) 

ggplot(data_long5, aes(x = Valeur, fill = Groupe)) +
  geom_histogram(bins = 20, alpha = 0.5, color = "black", position = "identity") +
  scale_fill_manual(values = c("T" = "darkblue", "C" = "darkred"), name = "Groupe") +
  theme_classic()+labs(title = "continue/binaire")

#### binaire/binaire

data6=as.data.frame(cbind(T_1_6[,1],C_1_6[,1]))
data_long6 = data6 %>%
  mutate(Groupe_T = "T", Groupe_C = "C") %>%
  tidyr::pivot_longer(cols = c(V1, V2), names_to = "Variable", values_to = "Valeur") %>%
  mutate(Groupe = ifelse(Variable == "V1", "T", "C")) 


ggplot(data_long6, aes(x = Valeur, fill = Groupe)) +
  geom_histogram(bins = 20, alpha = 0.5, color = "black", position = "identity") +
  scale_fill_manual(values = c("T" = "darkblue", "C" = "darkred"), name = "Groupe") +
  theme_classic() +labs(title = "binaire/binaire")
```

### Scénario 2 : C uniformément meilleur que T

```{r}
# tte/tte
T_2_1=cbind(gener_tte(0.8, 2.5),gener_tte(0.33,2.5))
C_2_1=cbind(gener_tte(1.1, 0.5),gener_tte(0.75,0.33))

# tte/continue
T_2_2=cbind(gener_continue(0,1),gener_tte(0.75,1.5))
C_2_2=cbind(gener_continue(2,1),gener_tte(0.75, 0.75))

# tte/binaire
T_2_3=cbind(gener_tte(0.33,2.3),gener_binom(0.45))
C_2_3=cbind(gener_tte(0.75,0.5),gener_binom(0.75))

# continue/continue
T_2_4=cbind(gener_continue(2,1),gener_continue(1,1))
C_2_4=cbind(gener_continue(3,1),gener_continue(3,2))

# continue/binaire
T_2_5=cbind(gener_continue(0,2),gener_binom(0.35))
C_2_5=cbind(gener_continue(2.5,1),gener_binom(0.65))

# binaire/binaire
T_2_6=cbind(gener_binom(0.45), gener_binom(0.5))
C_2_6=cbind(gener_binom(0.75), gener_binom(0.65))
```


### Scénario 3 : T similaire à C

```{r}
# tte/tte
T_3_1=cbind(gener_tte(0.5),gener_tte(0.5))
C_3_1=cbind(gener_tte(0.5),gener_tte(0.5))

# tte/continue
T_3_2=cbind(gener_tte(0.5),gener_continue(2))
C_3_2=cbind(gener_tte(0.5),gener_continue(2))

# tte/binaire
T_3_3=cbind(gener_tte(0.5),gener_binom(0.45))
C_3_3=cbind(gener_tte(0.5),gener_binom(0.45))

# continue/continue
T_3_4=cbind(gener_continue(2),gener_continue(2))
C_3_4=cbind(gener_continue(2),gener_continue(2))

# continue/binaire
T_3_5=cbind(gener_continue(2),gener_binom(0.45))
C_3_5=cbind(gener_continue(2),gener_binom(0.45))

# binaire/binaire
T_3_6=cbind(gener_binom(0.5), gener_binom(0.5))
C_3_6=cbind(gener_binom(0.5), gener_binom(0.5))
```

## GPC

```{r, echo = TRUE}

type_variable = function(vecteur1, L) {
  type = rep(0, L)
  
  type = sapply(vecteur1, function(x) {
    classe = class(x)
    
    if ("Surv" %in% classe) {
      return("tte")
    } else if ("numeric" %in% classe) {
      return("continue")
    } else {
      return("binaire")
    }
  })
  
  return(unname(type))
}
```

```{r, echo=TRUE}
extract_tte=function(vecteur1,l){
  if (type_variable(vecteur1,l)[l]!="tte"){ stop("la variable n'est pas tte")}
  t_obs=vecteur1[[l]][,1]
  censure=vecteur1[[l]][,2]
  return(cbind(t_obs,censure))
}
```

```{r, echo=TRUE }
# Entrée :
# vecteur1 : les valeurs du nouveau traitement
# vecteur2 : les valeurs du traitement de contrôle 
# L : le nb d'outcomes
# w : le poids de chaque outcome ; par défault égal à 1
# threshold : le seuil pour les valeurs continues ou tte ; par défalut égal à 0

# renvoie :
# results : dataframe comportant le WR, la Win Proportion,, les WO et la GPC
# CI : les intervalles de confiance à 95 des WR et de la Win proportion
# Nb : les nb de win, de loose et de tie
# z_score : le z_score utile pour calculer la p-valeur des WR
# p_value_unilatéral/bilatéral : la p valeur du test unilatéral ou bilatéral sous H_0

affect_value_GPC_WO_WR = function(vecteur1, vecteur2, L, w = rep(1, L), threshold = 0) {
  n1 = nrow(vecteur1)
  n2 = nrow(vecteur2)


  type1 = type_variable(vecteur1, L)
  type2 = type_variable(vecteur2, L)

  if (!all(type1 == type2)) {
    stop("Les deux vecteurs ont des outcomes de types différents")
  }

  paire = matrix("", nrow = n1 * n2, ncol = L)
  Delta = 0
  N_w = 0
  N_l = 0
  N_t = 0
  p = 1 


 for (i in 1:n1) {
  for (j in 1:n2) {
    for (l in 1:L) {
      if (type1[l] == "tte") {
        
        t_obs1 = extract_tte(vecteur1, l)[,1]
        censure1 = extract_tte(vecteur1, l)[,2]
        t_obs2 = extract_tte(vecteur2, l)[,1]
        censure2 = extract_tte(vecteur2, l)[,2]
        diff_tte = t_obs1[i] - t_obs2[j]
        
        if (censure1[i] == 0 && censure2[j] == 0) {
          if (diff_tte > threshold) {
            paire[p, l] = "favorable"
          } else if (diff_tte < -threshold) {
            paire[p, l] = "défavorable"
          } else {
            paire[p, l] = "neutre"
          }
        } else if (censure1[i] == 1 && censure2[j] == 0) {
          if (diff_tte > threshold) {
            paire[p, l] = "favorable"
          } else {
            paire[p, l] = "non-informative"
          }
        } else if (censure1[i] == 0 && censure2[j] == 1) {
          if (diff_tte > threshold) {
            paire[p, l] = "non-informative"
          } else {
            paire[p, l] = "défavorable"
          }
        } else {
          paire[p, l] = "non-informative"
        }
      }
      
      if (type1[l] == "continue") {
        diff = vecteur1[i, l] - vecteur2[j, l]
        if (diff > threshold) {
          paire[p, l] = "favorable" 
        } else if (diff < -threshold) {
          paire[p, l] = "défavorable"
        } else {
          paire[p, l] = "neutre"
        }
      }
      
      if (type1[l] == "binaire") {
        if (vecteur1[i, l] == 1 && vecteur2[j, l] == 0) {
          paire[p, l] = "favorable"
        } else if (vecteur1[i, l] == 0 && vecteur2[j, l] == 1) {
          paire[p, l] = "défavorable"
        } else {
          paire[p, l] = "neutre"
        }
      }
    }
    p = p + 1 
  }
  }


 for (p in 1:(n1 * n2)) {
  valeur_trouvee = FALSE 

  for (l in 1:L) {
    if (paire[p, l] != "non-informative") {
      if (paire[p, l] == "favorable") {
        N_w = N_w + 1
      } else if (paire[p, l] == "défavorable") {
        N_l = N_l + 1
      } else if (paire[p, l] == "neutre") {
        N_t = N_t + 1
      }
      valeur_trouvee = TRUE
      break  
    }
  }
  }
  
  #count_non_informative_pairs = sum(paire[, 1] == "non-informative" & paire[, 2] == "non-informative")
  #cat("Nb de paire non-informative : ",count_non_informative_pairs,"\n")
  #cat("Nb de win",N_w,"\n")
  #cat("Nb de lose : ",N_l,"\n")
  #cat("Nb de tie : ",N_t,"\n")
  #cat("Nb de paire regardée :", count_non_informative_pairs+N_w+N_l+N_t,"\n")
  
  
  # Calcul des statistiques finales
  Delta = round((N_w - N_l) / (n1 * n2),3)
  WR = round(ifelse(N_l != 0, N_w / N_l, NA),3)
  WO = round(ifelse(N_t != 0, (N_w + 0.5 * N_t) / (N_l + 0.5 * N_t), WR),3)
  P_w=round((N_w)/(N_w+N_l),3)
  
  P_L=round(P_w-1.96*sqrt((P_w*(1-P_w))/(N_w+N_l)),3)
  P_U=round(P_w+1.96*sqrt((P_w*(1-P_w))/(N_w+N_l)),3)
  
  sigma_emp <- sqrt((P_w * (1 - P_w)) / (N_w + N_l))
  z <- (P_w - 0.5) / sigma_emp
  p_val=1-pnorm(z)
  
  p_val_uni<- 1 - pnorm(z)
  p_val_bilat <- 2 * (1 - pnorm(abs(z))) 
  
  data1 = data.frame(WinRatio = WR, Win_Prop = P_w, WinOdds = WO, GPC = Delta, row.names = "")
  data2 = data.frame(row.names = c("Win proportion", "Win ratio"), lower = c(P_L, round(P_L/(1-P_L), 3)), upper = c(P_U, round(P_U/(1-P_U), 3)))
  data3=data.frame(Nb_win=N_w, Nb_lose=N_l, Nb_tie=N_t, row.names = "")

return(list(results=data1,CI=data2, Nb=data3, z_score=z, p_value_unilatéral=p_val_uni, p_value_bilatéral=p_val_bilat))
}
```

```{r}
resultats=affect_value_GPC_WO_WR(T_2_4, C_2_4, 2)
resultats

#affect_value_GPC_WO_WR(T_2_2, C_2_2, 2)
#affect_value_GPC_WO_WR(T_3_6, C_3_6, 2)
```

```{r}
n_sim=300
result_GPC=rep(0,n_sim)
result_WO=rep(0,n_sim)
result_WR=rep(0,n_sim)
Nb_win=rep(0,n_sim)
start_time <- Sys.time()

for (i in 1:n_sim) {

  vecteur1 = cbind(gener_tte(0.75, 0.75),gener_continue(2,1))
  vecteur2=cbind(gener_tte(0.75,1.5),gener_continue(0,1))
  

  result <- affect_value_GPC_WO_WR(vecteur1, vecteur2, L = 2)
  result_GPC[i]= result$results[,4]
  result_WR[i]=result$results[,1]
  result_WO[i]=result$results[,3]
  
  Nb_win[i]=result$Nb[,1]
}
end_time <- Sys.time()
total_time <- end_time - start_time
print(paste("Temps total pour 100 simulations:", total_time))
mean_GPC <- mean(result_GPC)
mean_WR <- mean(result_WR)
mean_WO <- mean(result_WO)
result_GPC

alpha <- 0.05
lower_quantile <- quantile(result_GPC, probs = alpha / 2)
upper_quantile <- quantile(result_GPC, probs = 1 - alpha / 2)
cat("Intervalle de confiance à", (1 - alpha) * 100, "% : [", lower_quantile, ",", upper_quantile, "]\n")

sum(result_GPC>=upper_quantile)

obs <- mean_GPC
hist(result_GPC, breaks = 20, main = "Distribution empirique", col = "lightblue", xlim=c(0.35,0.6))
abline(v = obs, col = "red", lwd = 2, lty = 2)


# Calcul des p-valeurs empiriques
s1 <- sum(result_GPC >= obs)
print(s1)

p_val_emp_unilateral <- s1 / n_sim

cat("P-valeur empirique unilatérale :", p_val_emp_unilateral, "\n")
mean(Nb_win)
wilcox.test(T_1_4[,1],C_1_4[,1])

```
